import tensorflow as tf
import zarr
import numpy as np
import os


class ExternalChannelLoader:
    """
    Loads Rays and Topology from Zarr dataset generated by generate_dataset.py.
    Provides Rays and LSPs (Pathloss, Shadow Fading, K-Factor).
    """

    def __init__(self, zarr_path):
        self.zarr_path = zarr_path
        self.root = zarr.open(zarr_path, mode="r")
        self.cached_drop_idx = -1
        self.cached_topology = {}
        self.cached_rays_data = {}
        self.cached_lsp_data = {}

    def load_drop(self, drop_idx):
        """
        Loads the specified drop into memory cache.
        """
        if drop_idx == self.cached_drop_idx:
            return

        drop_group = self.root[f"drop_{drop_idx}"]

        # Load Topology
        topo_g = drop_group["topology"]
        self.cached_topology = {
            "ut_loc": tf.constant(topo_g["ut_loc"][:], dtype=tf.float32),
            "bs_loc": tf.constant(topo_g["bs_loc"][:], dtype=tf.float32),
            "ut_orient": tf.constant(topo_g["ut_orient"][:], dtype=tf.float32),
            "bs_orient": tf.constant(topo_g["bs_orient"][:], dtype=tf.float32),
            "ut_vel": tf.constant(topo_g["ut_vel"][:], dtype=tf.float32),
            "in_state": tf.constant(topo_g["in_state"][:], dtype=tf.bool),
            "los": tf.constant(topo_g["los"][:], dtype=tf.bool),
            "serving_cell_id": tf.constant(
                topo_g["serving_cell_id"][:], dtype=tf.int32
            ),
        }

        # Load Rays
        rays_g = drop_group["rays"]
        # Rays: [1, NumUT, NumBS, Paths]
        self.cached_rays_data = {
            "delays": tf.constant(rays_g["delays"][:], dtype=tf.float32),
            "powers": tf.constant(rays_g["powers"][:], dtype=tf.float32),
            "aoa": tf.constant(rays_g["aoa"][:], dtype=tf.float32),
            "aod": tf.constant(rays_g["aod"][:], dtype=tf.float32),
            "zoa": tf.constant(rays_g["zoa"][:], dtype=tf.float32),
            "zod": tf.constant(rays_g["zod"][:], dtype=tf.float32),
            "xpr": tf.constant(rays_g["xpr"][:], dtype=tf.float32),
        }

        # Load LSPs
        # LSPs: [1, NumBS, NumUT]
        # Note: Saved as [Batch, NumBS, NumUT] according to generate_dataset logic
        self.cached_lsp_data = {
            "pathloss": tf.constant(rays_g["pathloss"][:], dtype=tf.float32),
            "shadow_fading": tf.constant(rays_g["shadow_fading"][:], dtype=tf.float32),
            "k_factor": tf.constant(rays_g["k_factor"][:], dtype=tf.float32),
        }

        self.cached_drop_idx = drop_idx

    def get_topology(self):
        """
        Returns cached topology dictionaries.
        """
        if self.cached_drop_idx == -1:
            raise RuntimeError("No drop loaded. Call load_drop() first.")
        return self.cached_topology

    def get_rays(self, ut_indices=None, bs_indices=None):
        """
        Returns rays and LSPs for specified UTs and BSs.
        If indices are None, returns all.
        Returns: Dictionary containing both Rays tensors and LSP tensors.
        Rays: [1, U_sub, B_sub, Paths]
        LSPs: [1, B_sub, U_sub]
        """
        if self.cached_drop_idx == -1:
            raise RuntimeError("No drop loaded. Call load_drop() first.")

        results = {}

        # Slice Rays: [1, UT, BS, Paths] -> Gather UT(axis 1), BS(axis 2)
        for key, tensor in self.cached_rays_data.items():
            t_slice = tensor
            if ut_indices is not None:
                t_slice = tf.gather(t_slice, ut_indices, axis=1)
            if bs_indices is not None:
                t_slice = tf.gather(t_slice, bs_indices, axis=2)
            results[key] = t_slice

        # Slice LSPs: [1, BS, UT] -> Gather BS(axis 1), UT(axis 2)
        for key, tensor in self.cached_lsp_data.items():
            t_slice = tensor
            if bs_indices is not None:
                t_slice = tf.gather(t_slice, bs_indices, axis=1)
            if ut_indices is not None:
                t_slice = tf.gather(t_slice, ut_indices, axis=2)
            results[key] = t_slice

        return results
